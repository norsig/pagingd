#!/usr/bin/perl -w

#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
#-#
#-# DSPS (Digital Services Paging System) - Version 3
#-#
#-# Copyright (c) 2013 National Public Radio (Digital Services)
#-#
#-# Permission is hereby granted, free of charge, to any person obtaining a copy
#-# of this software and associated documentation files (the "Software"), to deal
#-# in the Software without restriction, including without limitation the rights
#-# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
#-# copies of the Software, and to permit persons to whom the Software is
#-# furnished to do so, subject to the following conditions:
#-#
#-# The above copyright notice and this permission notice shall be included in
#-# all copies or substantial portions of the Software.
#-#
#-# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
#-# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
#-# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
#-# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
#-# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
#-# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
#-# THE SOFTWARE.
#-#
#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#

# this can be altered here or via the '-t' command-line argument
our $g_bTEST_RUN = 0;

use Proc::Daemon;
use String::Random qw(random_string);
use Sys::Syslog qw(:standard :macros);
use HTTP::Daemon;
use IO::Select;
use Getopt::Long;
use CGI qw();
use Net::SMTP;
use Cwd 'abs_path';
use POSIX qw(strftime);
use MIME::QuotedPrint::Perl;
use LWP 5.64;
use lib "/usr/local/bin/dsps3";
use DSPS_User;
use DSPS_Room;
use DSPS_Debug;
use DSPS_Escalation;
use DSPS_Alias;
use DSPS_Config;
use DSPS_String;
use DSPS_CmdPermission;
use DSPS_SystemFilter;
use DSPS_Util;
use DSPS_Version;
use DSPS_Test;
use strict;

#-#-#-#-#-#-#-#-#-#-##-#-#-#-#-#-#-#-#-#-#-#-#-#-#
# Debugging is available on a per topic basis.  To include syslog debug detail simply
# bitwise "OR" all the topics you want to see together in $g_iDebugTopics.  For example, to
# see information about user issues and room issues you might set:
# $g_iDebugTopics = D_users | D_rooms;
# You can also use 0 or D_all.
# To see everything except a particular subset you can use bitwise negation to subtract
# particular components.  Remember to AND them instead of OR.  For example, for everything
# except state data:
# $g_iDebugTopics = D_all & ~D_state;
# All the D_xxxxx debug constants are listed in DSPS_Debug.pm.
#-#-#-#-#-#-#-#-#-#-##-#-#-#-#-#-#-#-#-#-#-#-#-#-#
#our $g_iDebugTopics = D_all & ~D_users & ~D_state & ~D_configRead & ~D_rooms;
our $g_iDebugTopics = 0;
our $g_iTestingDebugTopics = D_all & ~D_users & ~D_state & ~D_configRead & ~D_rooms;

# drop root privs to become 'nobody'
$< = $> = 65534 unless ($< == 65534);

# process name
my $g_sOriginalPath = $0;
$0 = "dsps: client process (perl) $g_sOriginalPath @ARGV";

# configure signal handlers
my $tSignalSet        = POSIX::SigSet->new();
my $tSignalActionTerm = POSIX::SigAction->new("handlerDaemonExit", $tSignalSet, &POSIX::SA_NODEFER);
my $tSignalActionHup  = POSIX::SigAction->new("handlerSigHup", $tSignalSet, &POSIX::SA_NODEFER);
my $tSignalActionInt  = POSIX::SigAction->new("handlerSigInt", $tSignalSet, &POSIX::SA_NODEFER);

# we fork children for numerous things; we don't care when they exit
$SIG{CHLD} = 'IGNORE';

# we get sigpipes occasionally if the client sending a message to the server closes the connection
# before the server can reply.  we don't want those to kill our app.
$SIG{PIPE} = 'IGNORE';

# globals
my $g_tListenerSocket;
my $g_sConfigFilename = '';
my $g_iTodayDate      = 0;
my $g_iNumPagesToday  = 0;

# these one-liners exist as functions so they can be called by some of the included modules
# essentially these avoid circular include dependencies
sub getRecoveryRegex()              {return parseRegex($g_hConfigOptions{nagios_recovery_regex});}
sub getProblemRegex()               {return parseRegex($g_hConfigOptions{nagios_problem_regex});}
sub getShowNonHuman()               {return $g_hConfigOptions{show_nonhuman};}
sub getAdminEmail()                 {return $g_hConfigOptions{admin_email};}
sub getRTLink()                     {return $g_hConfigOptions{rt_link};}
sub getUsersEscalationsEmails($)    {return DSPS_Escalation::getUsersEscalationsEmails(shift);}
sub getLogRoomsTo()                 {return $g_hConfigOptions{log_rooms_to};}
sub getAllNagiosFilterTillGlobal()  {DSPS_SystemFilter::getAllNagiosFilterTill();}
sub setAllNagiosFilterTillGlobal($) {DSPS_SystemFilter::setAllNagiosFilterTill(shift);}
sub getSummaryReminder()            {return $g_hConfigOptions{summary_reminder};}
sub writeConfig()                   {return DSPS_Config::writeConfig();}

#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
# Signal handler for a SIGTERM
#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
sub handlerDaemonExit() {
    if ($g_tListenerSocket) {
        $g_tListenerSocket->shutdown(2);
        $g_tListenerSocket->close();
    }
    saveState();
    checkpointMetrics(1);
    unlink(C_PIDPath);
    infoLog('daemon exiting on signal');
    closelog();    # syslog
    exit(0);
}

#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
# Signal handler for a SIGHUP
#-#-#-#-#-#-#-#-#-#-##-#-#-#-#-#-#-#-#-#-#-#-#-#-#
sub handlerSigHup() {
    infoLog('daemon caught SIGHUP - restarting');
    saveState();
    checkpointMetrics(1);
    unlink(C_PIDPath);
    exec(abs_path($g_sOriginalPath) . ' -d') or die("can't exec()");
}

#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
# Signal handler for a SIGINT
#-#-#-#-#-#-#-#-#-#-##-#-#-#-#-#-#-#-#-#-#-#-#-#-#
sub handlerSigInt() {
    print "\n" . infoLog('daemon caught SIGINT (cntrl-C) - exiting');
    print "*** NOTE: Don't forget to restart the daemon with -d\n";
    if ($g_tListenerSocket) {
        $g_tListenerSocket->shutdown(2);
        $g_tListenerSocket->close();
    }
    unlink(C_PIDPath);
    saveState();
    checkpointMetrics(1);
    closelog();    # syslog
    exit(0);
}



sub checkpointMetrics() {
    my $bForce = shift || 0;
    my $iStartingDate = $g_iTodayDate;
    $g_iTodayDate = strftime("%Y%m%d", localtime);

    if ($iStartingDate) {
        if ($bForce || ($g_iTodayDate != $iStartingDate)) {
            open(LOG, ">>" . C_MetricLog) || return (infoLog('Unable to write to ' . C_MetricLog));
            print LOG "$iStartingDate: $g_iNumPagesToday\n";
            close(LOG);

            # reset for new day
            $g_iNumPagesToday = 0;
        }
    }
}

#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
# Determine the server address - this is used for
# both the address to listen on and the address
# to connect to for a remote server.
#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
sub getServerAddress($$$) {
    my $bListen     = shift;
    my $sServerAddr = shift;                                        # defaults
    my $iServerPort = shift;
    my $sOption     = $bListen ? 'server_listen' : 'dsps_server';

    if (defined $g_hConfigOptions{$sOption}) {
        if ($g_hConfigOptions{$sOption} =~ /^((?:http(?:s)*:\/\/)*\S+)\s*:\s*(\d+)\s*$/) {
            $sServerAddr = $1;
            $iServerPort = $2;
        }
        elsif ($g_hConfigOptions{$sOption} =~ /^\s*:*\s*(\d+)\s*$/) {
            $iServerPort = $1;
        }
        elsif (($g_hConfigOptions{$sOption} =~ /:/) && ($g_hConfigOptions{$sOption} !~ /^\s*http(?:s)*:\/\//i)) {
            infoLog("ERROR:  invalid '$sOption' definition in configuration file; defaulting to $sServerAddr:$iServerPort");
        }
        elsif ($g_hConfigOptions{$sOption} =~ /^((?:http(?:s)*:\/\/)*\S+)\s*$/) {
            $sServerAddr = $1;
            $iServerPort = 443 if ($sServerAddr =~ /^\s*https:\/\//i);
        }
    }

    return ($sServerAddr, $iServerPort);
}

#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
# Save all state data to a file except for current
# room occupants.
#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
sub saveState() {
    open(STATE, ">" . C_StatePath) || return infoLog('Unable to save state (need write access to ' . C_StatePath . ')');
    print STATE DSPS_User::freezeState() . "\n";
    print STATE DSPS_SystemFilter::freezeState() . "\n";
    print STATE DSPS_User::freezeMessageState();
    close(STATE);
    debugLog(D_state, "saved system state to " . C_StatePath);
}

#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
# Read state data from a file
#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
sub restoreState() {
    open(STATE, C_StatePath) || return infoLog('No saved state to restore (' . C_StatePath . ')');
    my $sUsers      = <STATE>;
    my $sSysFilters = <STATE>;
    my @aMessage    = <STATE>;
    close(STATE);
    chomp($sUsers);
    chomp($sSysFilters);

    DSPS_User::thawState($sUsers);
    DSPS_User::thawMessageState(join('', @aMessage));
    DSPS_SystemFilter::thawState($sSysFilters);
    debugLog(D_state, "restored system state from " . C_StatePath);
}

#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
# Send an email - $sMessage should start with the
# Subject line, then a blank line, then the message
#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
sub sendEmail($$$) {
    my $sTo      = shift;
    my $sCc      = shift;
    my $sMessage = shift;
    my $sFrom    = $g_hConfigOptions{smtp_from} ? $g_hConfigOptions{smtp_from} : 'noreply@dsps';
    my $sHeader  = "From: $sFrom\n";

    print("*** EMAIL: $sMessage\n") if ($g_bTEST_RUN > 0);

    return if ($g_bTEST_RUN > 1);
    return infoLog("ERROR:  cannot send mail without 'smtp_server' set in config file") unless $g_hConfigOptions{smtp_server};
    return infoLog("WARNING: cannot send mail without a recipient") unless ($sTo || $sCc);

    my $tSMTP = Net::SMTP->new($g_hConfigOptions{smtp_server});
    $tSMTP->mail($sFrom);

    if ($g_bTEST_RUN) {
        if ($g_hConfigOptions{admin_email}) {
            foreach (split(/\s*[\s,;:]+\s*/, $g_hConfigOptions{admin_email})) {
                $tSMTP->to($_);
            }
            $sHeader .= "To: " . $g_hConfigOptions{admin_email} . "\n";
            debugLog(D_email, "$sFrom -> " . $g_hConfigOptions{admin_email} . " (due to $g_bTEST_RUN); normally To [$sTo], Cc [$sCc]");
        }
        else {
            infoLog("ERROR:  cannot send mail in $g_bTEST_RUN mode without 'admin_email' set in config file");
            $tSMTP->quit();
            return;
        }
    }
    else {
        my @aTo;
        foreach (split(/\s*[\s,;:]+\s*/, $sTo)) {
            $tSMTP->to($_);
            push(@aTo, $_);
        }
        $sHeader .= ("To: " . join(', ', @aTo) . "\n") if ($#aTo >= 0);

        my @aCc;
        foreach (split(/\s*[\s,;:]+\s*/, $sCc)) {
            $tSMTP->to($_);
            push(@aCc, $_);
        }
        $sHeader .= ("Cc: " . join(', ', @aCc) . "\n") if ($#aCc >= 0);
        debugLog(D_email, "$sFrom -> [$sTo], Cc [$sCc]");
    }

    $tSMTP->data();
    $tSMTP->datasend($sHeader);
    $tSMTP->datasend($sMessage);
    $tSMTP->dataend();
    $tSMTP->quit();
}

#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
# Execute an RT command potentially on a remote
# server.
#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
sub rtCommand($;$) {
    my $sCommand = shift;
    my $sInput = shift || '';
    my $sResult;

    # external server dependencies can slow us down.  so when it comes to adding ticket comments
    # we fork into the background and continue on immediately.
    if ($sInput) {
        unless (fork()) {
            $0 = "dsps: rt update process (perl) $g_sOriginalPath";

            # close the listening socket in the child
            $g_tListenerSocket->close();

            $sResult = `/bin/echo "$sInput" | $g_hConfigOptions{rt_connection} $sCommand`;
            debugLog(D_rt, "$sCommand [bg] returned  $sResult");
            exit(0);
        }
        return;
    }

    # unfortunately in the case of creating the ticket in the first place, that has to remain
    # foreground because we need to wait for it to return the ticket number.
    else {
        $sResult = `$g_hConfigOptions{rt_connection} $sCommand`;
    }

    debugLog(D_rt, "$sCommand returned  $sResult");
    return $sResult;
}

#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
# Execute an external command.
#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
sub forkExecCommand($) {
    my $sCommand = shift;

    return infoLog("FAKE EXEC Trigger: $sCommand") if $g_bTEST_RUN;

    unless (fork()) {
        $0 = "dsps: exec (perl) $g_sOriginalPath";

        # close the listening socket in the child
        $g_tListenerSocket->close();

        infoLog("Exec Trigger: $sCommand");
        exec($sCommand);
        exit(0);    # never get here
    }
}

#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
# Create a new RT ticket via rtCommand()
#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
sub rtCreateTicket($$$) {
    my $sMessage      = shift;
    my $sQueue        = shift;
    my $sSubject      = shift;
    my $iTicketNumber = 0;

    return 40313 if $g_bTEST_RUN;

    if (rtCommand("create -t ticket set queue=$sQueue subject=\\'$sSubject\\'") =~ /Ticket (\d+) created/) {
        $iTicketNumber = $1;
        infoLog("RT: created ticket $iTicketNumber");
    }

    return $iTicketNumber;
}

#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
# Substitute in all user macros
#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
sub replaceUserMacros($$) {
    my $iSender            = shift;
    my $sMessage           = shift;
    my $sCompressedMessage = $sMessage;
    my $sAt                = $g_hConfigOptions{require_at} ? '@' : '\b';
    $sCompressedMessage =~ s/\n//g;

    # look for sender's macros
    my %hMacros = defined($g_hUsers{$iSender}->{macros}) ? %{ $g_hUsers{$iSender}->{macros} } : ();
    foreach my $sMacro (keys %hMacros) {

        if ($sMessage =~ /$sAt($sMacro)\b/i) {
            $sMessage =~ s/$sAt($sMacro)\b/$hMacros{$sMacro}/gi;
            $sCompressedMessage = $sMessage;
            $sCompressedMessage =~ s/\n//g;
            infoLog("interpolated user's macro $sMacro");
        }
        elsif ($sCompressedMessage =~ /$sAt($sMacro)\b/i) {
            $sCompressedMessage =~ s/$sAt($sMacro)\b/$hMacros{$sMacro}/gi;
            $sMessage = $sCompressedMessage;
            infoLog("interpolated compressed user's macro $sMacro");
        }
    }

    return $sMessage;
}

#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
# Clean up a message before it goes out
#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
sub messagePostFixUp($) {
    my $sMessage           = shift;
    my $sCompressedMessage = $sMessage;
    my $sAt                = $g_hConfigOptions{require_at} ? '@' : '\b';
    $sCompressedMessage =~ s/\n//g;

    # strip hidden aliases
    foreach my $sAlias (keys %g_hAliases) {
        if ($g_hAliases{$sAlias}->{hidden}) {
            if ($sMessage =~ /$sAt($sAlias)\b/i) {
                $sMessage =~ s/$sAt($sAlias)\b//gi;
                $sCompressedMessage = $sMessage;
                $sCompressedMessage =~ s/\n//g;
                infoLog("redacted hidden alias '$sAlias'");
            }
            elsif ($sCompressedMessage =~ /$sAt($sAlias)\b/i) {
                $sCompressedMessage =~ s/$sAt($sAlias)\b//gi;
                $sMessage = $sCompressedMessage;
                infoLog("redacted hidden compressed alias '$sAlias'");
            }
        }
    }

    # remove multiples of spaces
    $sMessage =~ s/\s{2,}/ /g;
    $sMessage =~ s/^\s*//;
    $sMessage =~ s/\s*$//;

    return $sMessage;
}

#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
# Search the help list for a particular topic
#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
sub helpSearch($) {
    my $sTopic = shift;
    my @aResults;

    foreach my $sT (@A_HelpTopics) {
        if ($sT =~ /$sTopic/i) {
            push(@aResults, $sT);
        }
    }

    return @aResults;
}

#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
# Send an SMS page to a phone number
# Handles:
#   - max length trimming
#   - adding a random character to dedupe
#   - forking into bg for send - for instant return
#   - interpolating config into gateway's API
#   - logging result of the gateway API hit
#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
sub sendSmsPage($$) {
    my ($iCellNumber, $sMessage) = @_;

    # trim to 160 characters
    $sMessage = substr($sMessage, 0, 160) if length($sMessage) > 160;

    unless (DSPS_User::humanUsersPhone($iCellNumber)) {
        infoLog("dropping requested page to system user " . $g_hUsers{$iCellNumber}->{name} . ": $sMessage");
        return;
    }

    if ($iCellNumber =~ /^\s*$/) {
        infoLog("no number specified;  dropping outgoing page");
        sendEmail($g_hConfigOptions{admin_email}, '', "Subject: DSPS bug detected - blank user\n\nUsers are currently: " . join(', ', sort keys %g_hUsers));
        return;
    }

    # bail if testing
    if ($g_bTEST_RUN) {
        infoLog("FAKE PAGE " . $g_hUsers{$iCellNumber}->{name} . " ($iCellNumber): $sMessage");
        return;
    }

    # append a random character to make the message unique
    # (sms gateway companies often filter out dupes)
    if (DSPS_User::previouslySentTo($iCellNumber, $sMessage)) {
        if (length($sMessage) < 158) {
            $sMessage .= ' [' . random_string('s') . ']';
        }
        elsif (length($sMessage) < 160) {
            $sMessage .= random_string('s');
        }
        else {
            substr($sMessage, 159, 1) = random_string('s');
        }
    }

    # update global metrics
    $g_iNumPagesToday++;

    # fork a child to send the page.  that way pages to a large recipient list can become
    # a large number of children and go out near simultaneously
    return if fork();    # parent

    $0 = "dsps: page submission process (perl) $g_sOriginalPath";

    # close the listening socket in the child
    $g_tListenerSocket->close() if $g_tListenerSocket;    # socket not defined when called from exclusivePage()

    # prepare the gateway API call POST parameters from our config options
    my %hGatewayParams = ();
    if (defined $g_hConfigOptions{gateway_params}) {
        while ($g_hConfigOptions{gateway_params} =~ /\[([^ =\]\[]+)=([^ =\]\[]+)]/g) {
            my $sParam = $1;
            my $sValue = $2;

            $sValue =~ s/\$CELLNUMBER/$iCellNumber/g;
            $sValue =~ s/\$MESSAGE/$sMessage/g;

            $hGatewayParams{$sParam} = $sValue;
        }
    }

    # because we fork all outgoing messages into child procs they finish at different times.
    # there's no way to predict which will get to the user first.  we still can't guarantee but
    # if we add a second of sleep before audience update lines hopefully the actual messages
    # will get there first and the audience updates second.
    sleep(4) if ($sMessage =~ /^.{0,5}((Audience is now)|(DSPS Trigger))/);

    # send the page (perform POST)
    my $tBrowser = LWP::UserAgent->new;
    $tBrowser->timeout(10);
    my $tResponse = $tBrowser->post($g_hConfigOptions{gateway_url}, \%hGatewayParams);

    debugLog(D_pageEngine, "PAGE " . $g_hUsers{$iCellNumber}->{name} . " ($iCellNumber) [" . $tResponse->code() . "]: $sMessage");

    unless ($tResponse->is_success) {
        if (defined($g_hConfigOptions{fallback_email}) && open(MAIL, "| /usr/sbin/sendmail " . $g_hConfigOptions{fallback_email})) {
            print MAIL "DSPS can't send via gateway provider!";
            close(MAIL);

            if (open(ERROR_LOG, ">>/tmp/dsps.gateway.error")) {
                print ERROR_LOG localtime(time()) . " : to $iCellNumber received " . $tResponse->code() . "\n";
                print ERROR_LOG $tResponse->content() . "\n-------------------------------------------------------\n\n";
                close(ERROR_LOG);
            }
        }
    }

    exit(0);    # child
}

#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
# Construct the current status of all filters
#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
sub filterStatus($) {
    my $iSender = shift;
    my $iNow    = time();
    my $sResult = '';
    $sResult = "USR\nRecoveries: " . ($g_hUsers{$iSender}->{filter_recoveries} == 1 ? 'blocked' : $g_hUsers{$iSender}->{filter_recoveries} == 2 ? 'smart' : 'allowed') . "\n\n" if $iSender;

    $sResult .= "SYS\nLoad&Recvr: " . ($DSPS_SystemFilter::iFilterRecoveryLoadTill > $iNow ? 'blocked'                                                : 'allowed') . "\n";
    $sResult .= "AllNagios: " .       ($DSPS_SystemFilter::iFilterAllNagiosTill > $iNow    ? prettyDateTime($DSPS_SystemFilter::iFilterAllNagiosTill) : 'allowed') . "\n";
    $sResult .= "\nRegex:\n";

    my $sRegex = '';
    foreach my $iRegexID (sort keys %DSPS_SystemFilter::rFilterRegex) {
        if ($DSPS_SystemFilter::rFilterRegex{$iRegexID}->{till} > $iNow) {
            $sRegex .=
              ' /' . $DSPS_SystemFilter::rFilterRegex{$iRegexID}->{regex} . "/" . ($iSender ? '' : ' (' . prettyDateTime($DSPS_SystemFilter::rFilterRegex{$iRegexID}->{till}) . ')') . "\n";
        }
    }

    $sResult .= $sRegex ? $sRegex : " none.\n";
    return $sResult;
}

#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
# Process commands a user sends to the system
# Handles:
#   - checking permissions - that user vs that cmd
#   - doing the action
#   - returning result to the user
# Returns bool of whether or not a cmd was handled
#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
sub handlePagingCommands($$) {
    my ($iSender, $sMessage) = @_;
    my $sCommand;
    my $iSilenceModifier;
    my $sParams;

    # old style dash command
    $sMessage = ':leave' if $sMessage eq '-';

    # does the message parse as a command?
    if ($sMessage =~ /^\s*([:?])\s*(\w*)([-+]*)\s*(.*)/) {
        $sCommand = $1 . $2;
        $sCommand =~ tr[A-Z][a-z];
        $iSilenceModifier = $3;
        $iSilenceModifier = $iSilenceModifier eq '+' ? 1 : $iSilenceModifier eq '-' ? -1 : 0;
        $sParams          = $4;
        debugLog(D_pageEngine, "command=$sCommand, silenceMod=$iSilenceModifier, params=$sParams");

        # ask for room status
        if ($sCommand =~ /^\?room/) {
            if (DSPS_CmdPermission::checkAndRefutePermissions($iSender, '?rooms')) {
                my $iUsersRoom = DSPS_Room::findUsersRoom($iSender);
                my $sStatus = DSPS_Room::roomStatus((($sCommand eq '?room') && $iUsersRoom) ? $iUsersRoom : 0);
                sendSmsPage($iSender, t($sStatus));
                logPage($iSender, '', "received room status: $sStatus");
            }

            return 1;
        }

        # ask for recent rooms
        if ($sCommand =~ /^\?recent/) {
            if (DSPS_CmdPermission::checkAndRefutePermissions($iSender, '?recent')) {
                DSPS_Room::sendRecentRooms($iSender);
                logPage($iSender, '', "received recent rooms");
            }

            return 1;
        }

        # block all nagios pages
        if ($sCommand eq ':nonagios') {
            if (DSPS_CmdPermission::checkAndRefutePermissions($iSender, ':nonagios')) {
                my ($iSeconds, $sTimeText) = parseUserTime($sParams);

                DSPS_SystemFilter::setAllNagiosFilterTill(time() + $iSeconds);
                sendSystemMessageToRoom($iSender, "filtered all nagios alerts for $sTimeText", $iSilenceModifier);
            }

            return 1;
        }

        # re-enable nagios pages
        if ($sCommand eq ':nagios') {
            if (DSPS_CmdPermission::checkAndRefutePermissions($iSender, ':nonagios')) {
                DSPS_SystemFilter::setAllNagiosFilterTill(0);
                sendSystemMessageToRoom($iSender, "re-enabled all nagios alerts", $iSilenceModifier);
            }

            return 1;
        }

        # sleep command for no load or recovery pages
        if ($sCommand eq ':sleep') {
            if (DSPS_CmdPermission::checkAndRefutePermissions($iSender, ':sleep')) {
                my ($iSeconds, $sTimeText) = parseUserTime($sParams);

                DSPS_SystemFilter::setRecoveryLoadFilterTill(time() + $iSeconds);
                sendSystemMessageToRoom($iSender, "filtered all recovery & load pages for $sTimeText", $iSilenceModifier);
            }

            return 1;
        }

        # re-enble load/recoveries
        if ($sCommand eq ':nosleep') {
            DSPS_SystemFilter::setRecoveryLoadFilterTill(0);
            sendSystemMessageToRoom($iSender, "re-enabled recovery & load pages", $iSilenceModifier);

            return 1;
        }

        # set a maintenance window room
        if ($sCommand eq ':maint') {
            my $bRoomStatus = 0;

            if (DSPS_CmdPermission::checkAndRefutePermissions($iSender, ':maint')) {
                my $sMaintUser = (defined($sParams) && $sParams) ? '@' . $sParams : (defined($g_hConfigOptions{default_maint}) && $g_hConfigOptions{default_maint}) ? '@' . $g_hConfigOptions{default_maint} : '';

                if ($sMaintUser && (my $iUserCell = DSPS_User::matchUserByRegex($sMaintUser))) {
                    my $iUserRoom = DSPS_Room::findUsersRoom($iUserCell);
                    my $iSenderRoom = DSPS_Room::findUsersRoom($iSender);

                    if ($iSenderRoom && $iSenderRoom == $iUserRoom && $g_hRooms{$iSenderRoom}->{maintenance}) {
                        sendSmsPage($iSender, t("This room is already in maintenance mode and " . $g_hUsers{$iUserCell}->{name} . " is part of the audience."));
                        return 1;
                    }
                }

                # pull in the maint user(s)
                $bRoomStatus = processMentions($iSender, $sMaintUser, $sMaintUser, 1);

                if ($bRoomStatus) {

                    # put the room in maintenancd mode
                    # note that we call findUsersRoom() again because it may have changed after processMentions()
                    $g_hRooms{DSPS_Room::findUsersRoom($iSender)}->{maintenance} = 1;

                    sendSystemMessageToRoom($iSender, S_NowInMaint, $iSilenceModifier);
                }
                else {
                    sendSmsPage($iSender, t("There's no default_maint user defined in the config.  Please specify a user via \":maint USER\""));
                }
            }
            return 1;
        }

        # enable ack-mode
        if ($sCommand eq ':ack') {
            if (DSPS_CmdPermission::checkAndRefutePermissions($iSender, ':ack')) {
                my $iRoom = DSPS_Room::findUsersRoom($iSender);

                if ($iRoom) {
                    $g_hRooms{$iRoom}->{ack_mode} = 1;
                    sendSystemMessageToRoom($iSender, "enabled acknowledgement mode for this room. Duplicate messages are automatically filtered.", $iSilenceModifier);
                }
                else {
                    sendSmsPage($iSender, t(S_NotInRoom));
                }
            }

            return 1;
        }

        # disable ack-mode
        if ($sCommand eq ':noack') {
            if (DSPS_CmdPermission::checkAndRefutePermissions($iSender, ':ack')) {
                my $iRoom = DSPS_Room::findUsersRoom($iSender);

                if ($iRoom) {
                    $g_hRooms{$iRoom}->{ack_mode} = 0;
                    sendSystemMessageToRoom($iSender, "disabled acknowledgement mode for this room.", $iSilenceModifier);
                }
                else {
                    sendSmsPage($iSender, t(S_NotInRoom));
                }
            }

            return 1;
        }

        # list all triggers
        if ($sCommand =~ /^\?trigger/) {
            if (DSPS_CmdPermission::checkAndRefutePermissions($iSender, '?triggers')) {
                my $sTriggers = DSPS_Trigger::listTriggers();
                sendSmsPage($iSender, t($sTriggers));
                logPage($iSender, '', "received trigger list: $sTriggers");
            }

            return 1;
        }

        # disarm a trigger
        if ($sCommand =~ /^:disarm/) {
            if (DSPS_CmdPermission::checkAndRefutePermissions($iSender, ':disarm')) {
                if ((defined $sParams) && $sParams) {
                    my $sResult = DSPS_Trigger::disarmTriggers($sParams);

                    if ($sResult) {
                        sendSmsPage($iSender, t($sResult));
                        logPage($iSender, '', "disarmed triggers matching $sParams");
                    }
                    else {
                        sendSmsPage($iSender, t(S_NoSuchTrigger));
                    }
                    return 1;
                }

                sendSmsPage($iSender, t(':disarm TRIGGER'));
            }

            return 1;
        }

        # arm a trigger
        if ($sCommand =~ /^:arm/) {
            if (DSPS_CmdPermission::checkAndRefutePermissions($iSender, ':arm')) {
                if ((defined $sParams) && $sParams) {
                    my $sResult = DSPS_Trigger::armTriggers($sParams);

                    if ($sResult) {
                        sendSmsPage($iSender, t($sResult));
                        logPage($iSender, '', "armed triggers matching $sParams");
                    }
                    else {
                        sendSmsPage($iSender, t(S_NoSuchTrigger));
                    }
                    return 1;
                }

                sendSmsPage($iSender, t(':arm TRIGGER'));
            }

            return 1;
        }

        # set a summary of the conversation
        if ($sCommand =~ /^:sum/) {
            if (DSPS_CmdPermission::checkAndRefutePermissions($iSender, ':sum')) {
                if ((defined $sParams) && $sParams) {

                    if ($sParams =~ /;/) {

                        # set room's summary
                        my $iRoom = DSPS_Room::findUsersRoom($iSender);
                        if ($iRoom) {
                            $g_hRooms{$iRoom}->{summary} = $sParams . " (via " . $g_hUsers{$iSender}->{name} . ")";

                            sendSystemMessageToRoom($iSender, "logged a summary for this conversation", $iSilenceModifier);
                        }
                        else {
                            sendSmsPage($iSender, t(S_SummaryTooLate));
                        }
                    }
                    else {
                        sendSmsPage($iSender, t("The :summary command requires a description and impact separated by a semi-colon."));
                    }

                    return 1;
                }

                sendSmsPage($iSender, t(':summary DESCRIPTION; IMPACT'));
            }

            return 1;
        }

        # set/edit a regex filter
        if ($sCommand =~ /^:((nore$)|(noreg))/) {

            if ($sParams =~ /(\d+\w{0,1})\s+(.*)/) {
                my $sTime  = $1;
                my $sRegex = parseRegex($2);

                if (DSPS_CmdPermission::checkAndRefutePermissions($iSender, ':noregex')) {
                    my ($iSeconds, $sTimeText) = parseUserTime($sTime);

                    if ($iSeconds) {
                        DSPS_SystemFilter::newRegexFilter($sRegex, time() + $iSeconds);
                        sendSystemMessageToRoom($iSender, "filtered automated pages matching /$sRegex/ for $sTimeText", $iSilenceModifier);
                    }
                    else {
                        if (DSPS_SystemFilter::rmRegexFilter($sRegex)) {
                            sendSystemMessageToRoom($iSender, "removed the filter for /$sRegex/");
                        }
                        else {
                            sendSmsPage($iSender, "Filter not found: /$sRegex/");
                        }
                    }

                }
            }
            else {
                sendSmsPage($iSender, t(':noregex ' . S_NeedTime));
            }

            return 1;
        }

        # show current filters
        if ($sCommand =~ /^\?filter/) {
            if (DSPS_CmdPermission::checkAndRefutePermissions($iSender, '?filters')) {
                my $sFilters = filterStatus($iSender);
                logPage($iSender, '', "received filter status: $sFilters");
                sendSmsPage($iSender, t($sFilters));
            }

            return 1;
        }

        # show vacation time
        if ($sCommand =~ /\?vaca/) {
            if (DSPS_CmdPermission::checkAndRefutePermissions($iSender, '?vacation')) {
                my %hVaca;
                my $iNow = time();

                foreach my $iUser (keys %g_hUsers) {
                    $hVaca{ $g_hUsers{$iUser}->{name} } = $g_hUsers{$iUser}->{vacation_end} if ($g_hUsers{$iUser}->{vacation_end} && $g_hUsers{$iUser}->{vacation_end} > $iNow);
                }

                if (keys %hVaca) {
                    my $sVaca = join("\n", map {"$_: " . prettyDateTime($hVaca{$_})} sort keys %hVaca);
                    sendSmsPage($iSender, t($sVaca));
                    logPage($iSender, '', "received vacation status: $sVaca");
                }
                else {
                    sendSmsPage($iSender, t(S_NoVacations));
                }
            }

            return 1;
        }

        # set/update vacation time
        if ($sCommand =~ /^:(?:no)*vaca/) {
            my ($iSeconds, $sTimeText);
            $sParams = '0' if ($sCommand =~ /^:no/);

            if (($sParams =~ /^\s*(\d+\w{0,1})\s*$/) || ($sParams =~ /(\d+)[-\/](\d+)[-\/](\d+)[\@: ]+(\d+):(\d+)/)) {

                if ($3) {
                    ($iSeconds, $sTimeText) = parseDateTime($1, $2, $3, $4, $5);
                }
                else {
                    ($iSeconds, $sTimeText) = parseUserTime($1);
                }

                if (DSPS_CmdPermission::checkAndRefutePermissions($iSender, ':vacation')) {
                    if ($iSeconds) {
                        $g_hUsers{$iSender}->{vacation_end} = time() + $iSeconds;
                        sendSmsPage($iSender, t("You have successfully set $sTimeText of vacation time."));
                        sendEmail(DSPS_Escalation::getUsersEscalationsEmails($iSender), $g_hConfigOptions{admin_email}, sv(E_VacationSet2, $g_hUsers{$iSender}->{name}, $sTimeText));
                        logPage($iSender, '', "set $sTimeText of vacation");
                    }
                    else {
                        $g_hUsers{$iSender}->{vacation_end} = 0;
                        sendSmsPage($iSender, t("You have canceled your vacation setting."));
                        sendEmail(DSPS_Escalation::getUsersEscalationsEmails($iSender), $g_hConfigOptions{admin_email}, sv(E_VacationCancel1, $g_hUsers{$iSender}->{name}));
                        logPage($iSender, '', "canceled remaining vacation time");
                    }
                }
            }
            else {
                sendSmsPage($iSender, t(S_VacaNeedTime));
            }

            return 1;
        }

        # add/update/delete a macro
        if ($sCommand eq ':macro') {
            if (DSPS_CmdPermission::checkAndRefutePermissions($iSender, ':macro')) {
                if ($sParams =~ /^(\w+)(?:\s+(.*))*/) {
                    my $sNewMacroName = $1;
                    my $sNewMacroDef  = $2;
                    my %hMacros       = defined($g_hUsers{$iSender}->{macros}) ? %{ $g_hUsers{$iSender}->{macros} } : ();
                    $sNewMacroName =~ tr/[A-Z]/[a-z]/;

                    if ($sNewMacroDef) {
                        if (defined $hMacros{$sNewMacroName}) {
                            sendSmsPage($iSender, t("Your macro " . $sNewMacroName . " has been updated."));
                        }
                        else {
                            sendSmsPage($iSender, t("Your macro " . $sNewMacroName . " has been added."));
                        }
                        $hMacros{$sNewMacroName} = $sNewMacroDef;
                        logPage($iSender, '', "set/updated macro $sNewMacroName ($sNewMacroDef)");
                    }
                    else {
                        if (defined $hMacros{$sNewMacroName}) {
                            delete($hMacros{$sNewMacroName});
                            sendSmsPage($iSender, t("Your macro " . $sNewMacroName . " has been deleted."));
                            logPage($iSender, '', "deleted macro $sNewMacroName");
                        }
                        else {
                            sendSmsPage($iSender, t("You don't have a macro named " . $sNewMacroName . " to delete."));
                        }
                    }

                    $g_hUsers{$iSender}->{macros} = \%hMacros;
                }
                else {
                    sendSmsPage($iSender, t("To define a macro specify ':macro MACRONAME DEFINITION'"));
                }

                return 1;
            }
        }

        # view your macros
        if ($sCommand =~ /\?macro/) {
            if (DSPS_CmdPermission::checkAndRefutePermissions($iSender, ':macro')) {
                my %hMacros = %{ $g_hUsers{$iSender}->{macros} };

                if ($sParams) {
                    $sParams =~ tr/[A-Z]/[a-z]/;
                    sendSmsPage($iSender, t(defined($hMacros{$sParams}) ? ("$sParams = \"" . $hMacros{$sParams} . '"') : "You don't have a macro named $sParams."));
                    logPage($iSender, '', defined($hMacros{$sParams}) ? "received detail of current macro $sParams" : "asked for definition of non-existent macro");
                }
                else {
                    sendSmsPage($iSender,
                        t(keys %hMacros ? ("Your macros: " . join(', ', sort keys %hMacros)) : "You don't have any macros defined.  Use ':macro NAME DEFINITION' to create some."));
                    sendSmsPage($iSender, t("Use '?macro NAME' to view the definition of a specific macro."));
                    logPage($iSender, '', "received list of current macros");
                }
            }

            return 1;
        }

        # erase all your macros
        if ($sCommand =~ /:nomacro/) {
            if (DSPS_CmdPermission::checkAndRefutePermissions($iSender, ':macro')) {

                if ($sParams) {
                    sendSmsPage($iSender,
                        t(":nomacro deletes ALL of your macros and takes no parameters. To delete a single macro use ':macro NAME DEF' but leave the definition blank. See '?macros'."));
                }
                else {
                    my %hMacros = ();
                    $g_hUsers{$iSender}->{macros} = \%hMacros;
                    sendSmsPage($iSender, t("All of your macros have been deleted."));
                    logPage($iSender, '', "deleted all of their macros");
                }
            }

            return 1;
        }

        # leave a room
        if ($sCommand eq ':leave') {
            my $iRoom = DSPS_Room::findUsersRoom($iSender);

            if ($iRoom) {
                sendSystemMessageToRoom($iSender, 'left the room.', $iSilenceModifier);
                DSPS_Room::roomRemoveOccupant($iRoom, $iSender);
                if (!DSPS_Room::roomHumanCount($iRoom)) {
                    DSPS_Room::logRoom($iRoom);
                    DSPS_Room::destroyRoom($iRoom);
                }
            }
            else {
                sendSmsPage($iSender, t(S_NotInRoom));
            }

            return 1;
        }

        # disband a room
        if ($sCommand eq ':disband') {
            if (DSPS_CmdPermission::checkAndRefutePermissions($iSender, ':disband')) {
                my $iRoom = DSPS_Room::findUsersRoom($iSender);

                if ($iRoom) {
                    sendSystemMessageToRoom($iSender, 'disbanded the room.', $iSilenceModifier);
                    DSPS_Room::logRoom($iRoom);
                    DSPS_Room::destroyRoom($iRoom);
                }
                else {
                    sendSmsPage($iSender, t(S_NotInRoom));
                }

            }

            return 1;
        }

        # pull occupants to a new room with sender
        if ($sCommand eq ':pull') {
            if (DSPS_CmdPermission::checkAndRefutePermissions($iSender, ':pull')) {

                if ($sParams) {
                    my $iOrigRoom = DSPS_Room::findUsersRoom($iSender);

                    if ($iOrigRoom) {
                        sendSystemMessageToRoom($iSender, 'disbanded the room.', $iSilenceModifier);

                        my $iNewRoom = DSPS_Room::cloneRoomMinusOccupants($iOrigRoom);
                        DSPS_Room::destroyRoom($iOrigRoom);
                        DSPS_Room::roomEnsureOccupant($iNewRoom, $iSender);
                        processMentions($iSender, $sParams, $sParams, 1);

                        my $sAudience =
                          S_AudienceUpdate . ' ' . DSPS_Room::roomStatus($iNewRoom) . ($g_hRooms{$iNewRoom}->{ticket_number} ? ('. Tkt: ' . $g_hRooms{$iNewRoom}->{ticket_number}) : '');

                        foreach my $iUserPhone (keys %{ $g_hRooms{$iNewRoom}->{occupants_by_phone} }) {
                            if (DSPS_User::humanUsersPhone($iUserPhone)) {
                                sendSmsPage($iUserPhone, t(($iSender == $iUserPhone ? 'You' : $g_hUsers{$iSender}->{name}) . " pulled: " . $sAudience));
                            }
                        }
                        logPage($iSender, '', "pulled into new room: $sAudience");
                    }
                    else {
                        sendSmsPage($iSender, t(S_NotInRoom));
                    }
                }
                else {
                    sendSmsPage($iSender, t(S_PullSyntax));
                }
            }

            return 1;
        }

        # enable smart sleep recoveries
        if ($sCommand =~ /^:smartrecover/) {
            if (DSPS_CmdPermission::checkAndRefutePermissions($iSender, ':norecovery')) {
                if ($g_hUsers{$iSender}->{filter_recoveries} == 2) {
                    sendSmsPage($iSender, t(S_SmartAlreadyF));
                }
                else {
                    $g_hUsers{$iSender}->{filter_recoveries} = 2;
                    sendSmsPage($iSender, t(S_SmartFiltered));
                    logPage($iSender, '', "enabled smart recoveries");
                }
            }

            return 1;
        }

        # disable recoveries for this user
        if ($sCommand =~ /^:norecover/) {
            if (DSPS_CmdPermission::checkAndRefutePermissions($iSender, ':norecovery')) {
                if ($g_hUsers{$iSender}->{filter_recoveries} == 1) {
                    sendSmsPage($iSender, t(S_RecoveryAlreadyF));
                }
                else {
                    $g_hUsers{$iSender}->{filter_recoveries} = 1;
                    sendSmsPage($iSender, t(S_RecoveryFiltered));
                    logPage($iSender, '', "disabled recoveries");
                }
            }

            return 1;
        }

        # enable recoveries for this user
        if ($sCommand =~ /^:recover/) {
            if (DSPS_CmdPermission::checkAndRefutePermissions($iSender, ':norecovery')) {    # same perms as above
                if ($g_hUsers{$iSender}->{filter_recoveries}) {
                    $g_hUsers{$iSender}->{filter_recoveries} = 0;
                    sendSmsPage($iSender, t(S_RecoveryEnabled));
                    logPage($iSender, '', "enabled recoveries (no filtering)");
                }
                else {
                    sendSmsPage($iSender, t(S_RecoveryAlreadyU));
                }
            }

            return 1;
        }

        # swap oncall schedules with another user
        if ($sCommand eq ':swap') {
            if (DSPS_CmdPermission::checkAndRefutePermissions($iSender, ':swap')) {
                if ($sParams =~ /^(\S+)(?:\s+(\S+))*/) {
                    my $sSwapee = $1;
                    my $sEsc    = $2;

                    DSPS_Escalation::swapSchedules($iSender, $sSwapee, $sEsc);
                    logPage($iSender, '', "swapped schedules with $sSwapee");
                }
                else {
                    sendSmsPage($iSender, t(S_SwapSyntax));
                }
            }

            return 1;
        }

        # show who's on call
        if ($sCommand eq '?oncall') {
            if (DSPS_CmdPermission::checkAndRefutePermissions($iSender, '?oncall')) {

                if ($sParams) {
                    if (my $sKey = caselessHashLookup($sParams, %g_hEscalations)) {
                        sendSmsPage($iSender, t(DSPS_Escalation::getFullOncallSchedule($sKey)));
                        logPage($iSender, '', "received oncall schedule for $sParams");
                    }
                    else {
                        sendSmsPage($iSender, t(S_NoSuchEscalation1, $sParams));
                    }
                }
                else {
                    my $sResult = '';

                    foreach my $sEsc (sort keys %g_hEscalations) {
                        my $sCurrent = DSPS_Escalation::getOncallPerson($sEsc);
                        $sCurrent = $g_hUsers{$sCurrent}->{name};
                        my $sScheduled = DSPS_Escalation::getScheduledOncallPerson($sEsc);
                        $sScheduled = $g_hUsers{$sScheduled}->{name};

                        $sResult = cr($sResult) . "$sEsc: " . ($sCurrent eq $sScheduled ? $sCurrent : "$sCurrent ($sScheduled vaca)");
                    }

                    sendSmsPage($iSender, t($sResult ? $sResult : S_NoEscalations));
                    logPage($iSender, '', "received general oncall schedules");
                }
            }

            return 1;
        }

        # set an autoreply
        if ($sCommand =~ /^:\s*(no)*(autoreply|ar)/) {
            if (DSPS_CmdPermission::checkAndRefutePermissions($iSender, ':autoreply')) {
                $sParams = '0' if ($sCommand =~ /^:no/);

                if ($sParams =~ /^(\S+)(?:\s+(.*))*/) {
                    my $sAutoReply = $2;
                    my ($iSeconds, $sTimeText) = parseUserTime($1);

                    if ($iSeconds) {
                        $g_hUsers{$iSender}->{auto_reply_text}   = $sAutoReply;
                        $g_hUsers{$iSender}->{auto_reply_expire} = time() + $iSeconds;
                        sendSmsPage($iSender, t(S_AutoReplySet1, $sTimeText));
                        logPage($iSender, '', "set auto reply '$sAutoReply' for $sTimeText");
                    }
                    else {
                        $g_hUsers{$iSender}->{auto_reply_text}   = '';
                        $g_hUsers{$iSender}->{auto_reply_expire} = 0;
                        sendSmsPage($iSender, t(S_AutoReplyRm));
                        logPage($iSender, '', "deleted auto reply");
                    }
                }
                else {
                    if (my $sAr = DSPS_User::getAutoReply($iSender)) {
                        sendSmsPage($iSender, t("Your current auto reply: \"$sAr\""));
                        logPage($iSender, '', "received current auto reply '$sAr'");
                    }
                    else {
                        sendSmsPage($iSender, t(S_AutoReplySyx));
                    }
                }
            }

            return 1;
        }

        # check an autoreply
        if ($sCommand =~ /^\?\s*(autoreply|ar)/) {
            if (DSPS_CmdPermission::checkAndRefutePermissions($iSender, ':autoreply')) {
                if (my $sAr = DSPS_User::getAutoReply($iSender)) {
                    sendSmsPage($iSender, t("Your current auto reply: \"$sAr\""));
                    logPage($iSender, '', "received current auto reply '$sAr'");
                }
                else {
                    sendSmsPage($iSender, t(S_AutoReplySyx));
                }
            }

            return 1;
        }

        # command help
        if ($sCommand =~ /^\?\s*command/) {
            sendSmsPage($iSender, t(S_HelpCommandsA));
            sendSmsPage($iSender, t(S_HelpCommandsB));
            return 1;
        }

        # general help
        if ($sCommand =~ /^\?\s*$/) {
            sendSmsPage($iSender, t(S_HelpGeneral));
            return 1;
        }

        # help search
        if ($sCommand =~ /^[?:]\s*help/) {
            if ($sParams) {
                my @aHelpTopics = helpSearch($sParams);

                foreach (@aHelpTopics) {
                    sendSmsPage($iSender, t($_));
                }

                sendSmsPage($iSender, t(S_NoSuchHelp)) if ($#aHelpTopics < 0);
                return 1;
            }

            sendSmsPage($iSender, t(S_HelpSyntax));
            return 1;
        }

        # list all groups & aliases
        if ($sCommand =~ /^\?\s*group/) {
            if (DSPS_CmdPermission::checkAndRefutePermissions($iSender, '?groups')) {
                sendSmsPage($iSender, t("Groups:\n" . join(', ', sort DSPS_Room::humanSort DSPS_User::allGroups())));
                sendSmsPage($iSender, t("Aliases:\n" . join(', ', sort(DSPS_Alias::visibleAliases())))) if (keys %g_hAliases);
                logPage($iSender, '', "received all groups/aliases");
            }

            return 1;
        }

        # email room history
        if ($sCommand eq ':email') {
            if (DSPS_CmdPermission::checkAndRefutePermissions($iSender, ':email')) {

                if ($sParams =~ /(\S+)/) {
                    my $sRecipient = $1;
                    my $iRoom      = DSPS_Room::findUsersRoom($iSender);
                    my @aHistory   = @{ $g_hRooms{$iRoom}->{history} };
                    my $sEmailText = join("\n", @aHistory);

                    if ($iRoom) {
                        sendEmail($sRecipient, '', "Subject:  DSPS room history\n\n[Emailed by " . $g_hUsers{$iSender}->{name} . "]\n\n$sEmailText");
                        sendSmsPage($iSender, t(S_EmailSent1, $sRecipient));
                        logPage($iSender, '', "sent room history to $sRecipient");
                    }
                    else {
                        sendSmsPage($iSender, t(S_YoureAlone));
                    }
                }
                else {
                    sendSmsPage($iSender, t(S_NeedEmail));
                }
            }

            return 1;
        }

        # identify group or person
        if ($sCommand =~ /^\?\s*(\S+)/) {
            if (DSPS_CmdPermission::checkAndRefutePermissions($iSender, '??')) {
                my $sEntity = $1;
                logPage($iSender, '', "received definition of $sEntity");

                # look for groups
                foreach my $sGroup (DSPS_User::allGroups()) {
                    if ($sEntity =~ /^$sGroup$/i) {
                        sendSmsPage($iSender, t("$sGroup = " . join(', ', sort map {$g_hUsers{$_}->{name}} DSPS_User::usersInGroup($sGroup))));
                        return 1;
                    }
                }

                # look for alises
                my $sAlias = caselessHashLookup($sEntity, %g_hAliases);
                if ($sAlias) {
                    sendSmsPage($iSender, t("$sAlias = " . $g_hAliases{$sAlias}->{referent}));
                    return 1;
                }

                # look for escalations
                my $sEsc = caselessHashLookup($sEntity, %g_hEscalations);
                if ($sEsc) {
                    my $sOnCall = DSPS_Escalation::getOncallPerson($sEsc);
                    sendSmsPage($iSender, t("Currently, $sEsc = " . ($sOnCall ? $g_hUsers{$sOnCall}->{name} : 'no one')));
                    return 1;
                }

                # look for people
                if (my $iUser = DSPS_User::matchUserByRegex($sEntity)) {
                    sendSmsPage($iSender, t($g_hUsers{$iUser}->{name} . ' = ' . prettyPhone($iUser)));
                    return 1;
                }

                sendSmsPage($iSender, t(S_NoSuchEntity));
                return 1;
            }
        }
        sendSmsPage($iSender, t(S_UnknownCommand));
        return 1;
    }

    # +NAME
    elsif ($sMessage =~ /^\s*\+\s*\@*(\S+)/) {
        my $sHistoryUser = $1;
        my $iRoom        = DSPS_Room::findUsersRoom($iSender);

        if ($iRoom) {
            my $iFoundRecipient = '';
            foreach my $iUser (keys %g_hUsers) {
                if ($sHistoryUser =~ /^$g_hUsers{$iUser}->{regex}$/i) {
                    $iFoundRecipient = $iUser;

                    my @aHistory = @{ $g_hRooms{$iRoom}->{history} };
                    my $iStartIndex = ($#aHistory < 4) ? 0 : $#aHistory - 4;

                    for my $iIndex ($iStartIndex .. $#aHistory) {
                        sendSmsPage($g_hUsers{$iUser}->{phone}, '>' . $aHistory[$iIndex]);
                    }

                    logPage($iSender, '', "sent +history to " . $g_hUsers{$iUser}->{name});
                    sendSmsPage($iSender, t("Room history (up to the last 5 messages) has been sent to " . $g_hUsers{$iUser}->{name}));

                    # pull that person into the room
                    processMentions($iSender, '@' . $g_hUsers{$iUser}->{name}, '@' . $g_hUsers{$iUser}->{name}, 0);
                    last;
                }
            }

            return 1 if $iFoundRecipient;
            sendSmsPage($iSender, t("There's no user named $sHistoryUser.  Note, you can't send room history to a group or alias."));
        }
        else {
            sendSmsPage($iSender, t(S_YoureAlone));
        }

        return 1;
    }
    else {
        return 0;
    }
}

#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
# Scan a message to see if anyone (people or
# groups) needs to be pulled into the room and if
# so pull them in.
# If an escalation tag is found, in addition to
# pulling the current on call person in, an
# escalation is primed (setup).  That can also
# lead to notification emails being sent from
# here if configured.
# Returns bool of whether or not the room makeup
# changed.
#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
sub processMentions($$$;$);



sub processMentions($$$;$) {
    my $sSender             = shift;
    my $sScanMessage        = shift;
    my $sRealMessage        = shift;
    my $bIncludeSystemUsers = shift || 0;
    my $bRoomChanged        = 0;
    my $bFoundSomeone       = 0;
    my $sAt                 = $g_hConfigOptions{require_at} ? '@' : '\b';

    # look for alias mentions
    foreach my $sAlias (keys %g_hAliases) {

        if ($sScanMessage =~ /$sAt($sAlias)\b/i) {
            debugLog(D_pageEngine, "found mention of alias $sAlias");
            my $sOrigMessage = $sScanMessage;
            $sScanMessage =~ s/$sAt($sAlias)\b/$g_hAliases{$sAlias}->{referent}/gi;
            $bRoomChanged = (processMentions($sSender, $sScanMessage, $sRealMessage) > 0) || $bRoomChanged;
            $sScanMessage = $sOrigMessage;
            $bFoundSomeone = 1;
        }
    }

    # look for group mentions
    foreach my $sGroup (DSPS_User::allGroups()) {
        next if $sGroup =~ /^\!/;

        if ($sScanMessage =~ /$sAt($sGroup)\b/i) {
            debugLog(D_pageEngine, "found mention of group $sGroup");

            my $iNow = time();
            foreach my $iUser (DSPS_User::usersInGroup($sGroup)) {

                if ($g_hUsers{$iUser}->{vacation_end} > $iNow) {
                    debugLog(D_pageEngine | D_users,
                        $g_hUsers{$iUser}->{name} . " excluded from $sGroup due to active vacation through " . prettyDateTime($g_hUsers{$iUser}->{vacation_end}));
                    next;
                }

                $bRoomChanged = DSPS_Room::combinePeoplesRooms($g_hUsers{$sSender}, $g_hUsers{$iUser}) || $bRoomChanged;
                $bFoundSomeone = 1;
            }
        }
    }

    # look for user mentions - similar to matchUserByRegex() but we need to continue iterating to look for all matches
    foreach my $iUserPhone (keys %g_hUsers) {
        next if !$bIncludeSystemUsers && $g_hUsers{$iUserPhone}->{name} =~ /^\!/;

        if ($sScanMessage =~ /$sAt($g_hUsers{$iUserPhone}->{regex})\b/i) {
            debugLog(D_pageEngine, "found mention of user " . $g_hUsers{$iUserPhone}->{name} . " ($iUserPhone)");
            $bRoomChanged = DSPS_Room::combinePeoplesRooms($g_hUsers{$sSender}, $g_hUsers{$iUserPhone}) || $bRoomChanged;
            $bFoundSomeone = 1;
        }
    }

    # look for escalation mentions
    # do escalations last in case other names were also mentioned that will satisfy the escalation's min_to_abort criteria
    foreach my $sEscName (keys %g_hEscalations) {

        if ($sScanMessage =~ /$sAt($sEscName)\b/i) {
            debugLog(D_pageEngine, "found mention of escalation $sEscName");
            $bRoomChanged = DSPS_Escalation::primeEscalation($sSender, $sEscName, $sRealMessage) || $bRoomChanged;
            $bFoundSomeone = 1;
        }
    }

    return ($bRoomChanged ? 1 : $bFoundSomeone ? -1 : 0);
}

#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
# Send a message that came from a user to all
# room occupants.
# Handles:
#   - ambiguous name warnings
#   - implementation of broadcast mode logic (who can talk)
#   - sending the audience update if necessary
#   - updating the RT ticket if configured
#   - prefixing with '+' if an escalation
#   - prefixing with user's name if they're human
#   - sending a user's Auto Reply if configured
#   - updating some room metadata that has to be done here
#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
sub sendUserMessageToRoom($$$);



sub sendUserMessageToRoom($$$) {
    my ($iSenderPhone, $sMessage, $bsUpdateAudience) = @_;
    my $sAmbiguousResult = '';

    # are there ambiguous names that we should warn the user about?
    # bypass if the message starts with a bang
    unless ($sMessage =~ /^\s*\!/) {
        foreach my $sAmbig (keys %g_hAmbigNames) {
            if ($sMessage =~ /\b($sAmbig)\b/i) {
                $sAmbiguousResult = "$1;;;" . $g_hAmbigNames{$sAmbig};
                last;
            }
        }
    }

    my $iRoom = DSPS_Room::findUsersRoom($iSenderPhone);

    unless ($iRoom) {

        if (!DSPS_User::humanUsersPhone($iSenderPhone)) {
            infoLog("Automation user " . $g_hUsers{$iSenderPhone}->{name} . " submitted a message with no audience mentions so we have no recipient; dropping message: $sMessage");
        }
        else {
            if ($sAmbiguousResult) {
                my ($sAmbName, $sAmbRef) = ($sAmbiguousResult =~ /(.*);;;(.*)/);
                sendSmsPage($iSenderPhone, t(S_AmbiguousReject2, $sAmbName, $sAmbRef));
            }
            else {
                sendSmsPage($iSenderPhone, t(S_YoureAlone));
            }
        }
        return;
    }

    # set bypass then drop bang prefixes, if present
    my $bBypass = ($sMessage =~ /^\!/);
    substr($sMessage, 0, 1) = '' if substr($sMessage, 0, 1) eq '!';

    # if this is a problem page from nagios record the time in the room
    $g_hRooms{$iRoom}->{last_problem_time} = time() if ($sMessage =~ parseRegex($g_hConfigOptions{nagios_problem_regex}));

    # track the last automation message for resends
    $g_hRooms{$iRoom}->{last_nonhuman_message} = $sMessage unless DSPS_User::humanUsersPhone($iSenderPhone);

    # determine the current audience
    # bsUpdateAudience can be false, true, or an addition message to prefix the audience with
    my $sAudience =
      t(  ((length($bsUpdateAudience) > 1) ? $bsUpdateAudience . ' ' : ($g_hRooms{$iRoom}->{maintenance} ? 'MAINT:' : ''))
        . S_AudienceUpdate . ' '
          . DSPS_Room::roomStatus($iRoom)
          . ($g_hRooms{$iRoom}->{ticket_number} ? ('. Tkt: ' . $g_hRooms{$iRoom}->{ticket_number}) : ''));

    # prepend the sender
    $sMessage = $g_hUsers{$iSenderPhone}->{name} . ": $sMessage"
      if DSPS_User::humanUsersPhone($iSenderPhone) && length($bsUpdateAudience) == 1;

    # update the room's history & expiration time
    push(@{ $g_hRooms{$iRoom}->{history} }, $sMessage);
    $g_hRooms{$iRoom}->{expiration_time} = time() + ROOM_LENGTH;

    # update the RT ticket if there is one, unless the user requests to bypass via a bang prefix
    rtCommand("comment -m - " . $g_hRooms{$iRoom}->{ticket_number}, $sMessage) if ($g_hRooms{$iRoom}->{ticket_number} && !$bBypass);

    # prepend a '+' if the message is going to escalate without a reply - i.e. an escalation is pending in the room
    $sMessage = '+' . $sMessage if (!DSPS_User::humanUsersPhone($iSenderPhone) && $g_hRooms{$iRoom}->{escalation_time} && ($sMessage !~ /^\+/));

    if ($sAmbiguousResult) {
        my ($sAmbName, $sAmbRef) = ($sAmbiguousResult =~ /(.*);;;(.*)/);
        sendSmsPage($iSenderPhone, t(S_AmbiguousIgnored1, $sAmbName));
    }

    # loop through room occupants
    my $sBlocks = '';
    foreach my $iUserPhone (keys %{ $g_hRooms{$iRoom}->{occupants_by_phone} }) {
        my $sBlockReason = '';

        # only text human users (recipients)
        # and either the sender has to also be human or if it's an automation sender then
        # it can't be blocked by this user's filters
        if (DSPS_User::humanUsersPhone($iUserPhone)
            && (DSPS_User::humanUsersPhone($iSenderPhone) || !($sBlockReason = DSPS_User::blockedByFilter($iUserPhone, \$sMessage, $g_hRooms{$iRoom}->{last_problem_time}))))
        {

            if (
                !$g_hRooms{$iRoom}->{broadcast_speaker} ||                    # if we're in a broadcast room
                ($g_hRooms{$iRoom}->{broadcast_speaker} == $iUserPhone) ||    # message has to be TO bc owner
                ($g_hRooms{$iRoom}->{broadcast_speaker} == $iSenderPhone)
              )
            {                                                                 # or FROM bc owner

                # the actual page - don't send to the sending user (no need to get your own message)
                # UNLESS it's an auto reply.  then they probably want to know that it's still set
                # and actually went out to people
                sendSmsPage($iUserPhone, $sMessage) unless (($iSenderPhone == $iUserPhone) && ($sMessage !~ /: \[Auto\] /));

                # an auto relpy (if set)
                if ($bsUpdateAudience && (my $sAr = DSPS_User::getAutoReply($iUserPhone))) {
                    sendUserMessageToRoom($iUserPhone, "[Auto] $sAr", 0);
                }
            }

            # the audience update
            sendSmsPage($iUserPhone, $sAudience) if $bsUpdateAudience;
        }

        if ($sBlockReason) {
            $sBlocks = cr($sBlocks, ', ') . $g_hUsers{$iUserPhone}->{name} . ":$sBlockReason";
        }
    }

    logPage($iSenderPhone, $sMessage, '', $sBlocks);
}



sub logPage($$;$$) {
    my $iSenderPhone = shift;
    my $sMessage     = shift;
    my $sAltText     = shift || '';
    my $sMinusPeople = shift || '';
    my $iRoom        = DSPS_Room::findUsersRoom($iSenderPhone);
    $sMessage     = $sMessage     ? ": $sMessage"      : '';
    $sMinusPeople = $sMinusPeople ? " - $sMinusPeople" : '';

    if ($iRoom) {
        my $sRoomType =
            ($g_hRooms{$iRoom}->{broadcast_speaker} ? 'B' : '')
          . ($g_hRooms{$iRoom}->{maintenance}       ? 'M' : '')
          . ($g_hRooms{$iRoom}->{ack_mode}          ? 'A' : '')
          . ($g_hRooms{$iRoom}->{ticket_number}     ? 'T' : '')
          . ($g_hRooms{$iRoom}->{escalation_time}   ? 'E' : '');
        $sRoomType = $sRoomType ? "[$sRoomType] " : '';

        if ($g_hRooms{$iRoom}->{broadcast_speaker}) {
            if ($iSenderPhone eq $g_hRooms{$iRoom}->{broadcast_speaker}) {
                infoLog($sRoomType . $g_hUsers{$iSenderPhone}->{name} . " -> " . ($sAltText || ("room $iRoom (" . DSPS_Room::roomStatus($iRoom) . "$sMinusPeople)")) . $sMessage);
            }
            else {
                infoLog($sRoomType . $g_hUsers{$iSenderPhone}->{name} . " -> " . ($sAltText || ("(" . $g_hUsers{ $g_hRooms{$iRoom}->{broadcast_speaker} }->{name} . ")")) . $sMessage);
            }
        }
        else {
            infoLog($sRoomType . $g_hUsers{$iSenderPhone}->{name} . " -> " . ($sAltText || ("room $iRoom (" . DSPS_Room::roomStatus($iRoom) . "$sMinusPeople)")) . $sMessage);
        }
    }
    else {
        infoLog($g_hUsers{$iSenderPhone}->{name} . " $sAltText$sMessage");
    }
}



sub shouldTell($) {
    my $iSilenceModifier = shift;
    return (($iSilenceModifier > 0) || (($iSilenceModifier == 0) && isDuringWakingHours()));
}

#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
# Send a message that DSPS originates to all
# room occupants.
# Handles:
#   - theming the message - t()
#   - sending to just a single user if no room
#   - silence modifier logic
#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
sub sendSystemMessageToRoom($$$) {
    my ($iSender, $sMessage, $iSilenceModifier) = @_;
    my $iRoom = DSPS_Room::findUsersRoom($iSender);
    logPage($iSender, '', $sMessage);

    # if the user isn't in a room then just send the message to that one person
    unless ($iRoom) {
        sendSmsPage($iSender, t('You have ' . $sMessage)) if (DSPS_User::humanUsersPhone($iSender));
        return;
    }

    # update room expiration
    $g_hRooms{$iRoom}->{expiration_time} = time() + ROOM_LENGTH;

    # loop through all room occupants
    foreach my $iUserPhone (keys %{ $g_hRooms{$iRoom}->{occupants_by_phone} }) {

        # only text human users
        if (DSPS_User::humanUsersPhone($iUserPhone)) {

            # iSilenceModifier is set by the presence of a plus or minus sign on the end of the user's command.  it translates to:
            #  1 (set by :command+), meaning always send the notification
            #  0 (set by :command), meaning send the notification based on it being during hours most people are awake
            # -1 (set by :command-), meaning never send the notification - e.g. only send it back to the person themself
            sendSmsPage($iUserPhone, t(($iSender == $iUserPhone ? ('You have ' . (shouldTell($iSilenceModifier) ? '' : 'silently ')) : $g_hUsers{$iSender}->{name} . ' has ') . $sMessage))
              if (shouldTell($iSilenceModifier) || ($iSender == $iUserPhone));
        }
    }
}

#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
# Send a message that DSPS originates to all
# room occupants.
# Handles:
#   - theming the message - t()
#   - sending to just a single user if no room
#   - silence modifier logic
#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
sub sendCustomSystemMessageToRoom($$$) {
    my ($iSender, $sMessage, $iSilenceModifier) = @_;
    my $iRoom = DSPS_Room::findUsersRoom($iSender);

    # if the user isn't in a room then just send the message to that one person
    unless ($iRoom) {
        sendSmsPage($iSender, t($sMessage)) if (DSPS_User::humanUsersPhone($iSender));
        return;
    }

    # update room expiration
    $g_hRooms{$iRoom}->{expiration_time} = time() + ROOM_LENGTH;

    # loop through all room occupants
    foreach my $iUserPhone (keys %{ $g_hRooms{$iRoom}->{occupants_by_phone} }) {

        # only text human users
        if (DSPS_User::humanUsersPhone($iUserPhone)) {

            next if (($iSilenceModifier < 2) && DSPS_User::blockedByFilter($iUserPhone, \$sMessage, $g_hRooms{$iRoom}->{last_problem_time}));

            # iSilenceModifier is set by the presence of a plus or minus sign on the end of the user's command.  it translates to:
            #  1 (set by :command+), meaning always send the notification
            #  0 (set by :command), meaning send the notification based on it being during hours most people are awake
            # -1 (set by :command-), meaning never send the notification - e.g. only send it back to the person themself
            sendSmsPage($iUserPhone, t($sMessage))
              if ( ($iSilenceModifier > 0)
                || (($iSilenceModifier == 0) && isDuringWakingHours())
                || ($iSender == $iUserPhone));
        }
    }
}

#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
# Ideally we get all messages sent to us via HTTP.
# But if we're accepting messages via email as
# part of our gateway interface (i.e. things people
# type into their phones), then those emails are
# likely to all be submitted to us via the same
# paging user that gets hardcoded in /etc/aliases.
# We need a way to tell who the actual paging user
# (sender) should be.  That's called overriding the
# user.  We have one paging user that submitted the
# email to us and we override it with the value of
# a user specified somewhere in the message.  If
# the admin has defined who the override_user is
# (that's the initial one, submitting the email)
# and an override_regex (which is how to pick the
# new user out of the message), then we can scan
# the message for that regex and make the
# substitution.  That's what's happening here.
# Returns the new user, if all conditions match.
#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
sub checkUserOverride($$) {
    my $sSender  = shift;
    my $sMessage = shift;

    # has the admin configured an override_user and override_regex?
    if (defined($g_hConfigOptions{override_user}) && defined($g_hConfigOptions{override_regex})) {
        my $sOverrideRegex = parseRegex($g_hConfigOptions{override_regex});

        # does the override_user's name match a configured user?
        if (my $sOverridePhone = DSPS_User::matchUserByName($g_hConfigOptions{override_user})) {

            # is the sender of the message the override_user?
            if (   (lc($sSender) eq lc($g_hUsers{$sOverridePhone}->{name}))
                || (('!' . lc($sSender)) eq lc($g_hUsers{$sOverridePhone}->{name})))
            {

                # does the message match the override_regex?
                if ($sMessage =~ m/$sOverrideRegex/mi) {
                    return $1;
                }
            }
        }
    }

    return '';
}

#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
# Main work of processing a page.
# Handles:
#   - checking for commands from the user
#   - interpolating in user macros
#   - checking all filters
#   - checking for escalation disarming
#   - maintenance mode logic
#   - auto_include logic for system users
#   - auto resend logic
#   - initiation of broadcast mode
#   - message clean up and standardization
#   - some room metadata updating
# Note $sSender at this point can be numeric (caller
# ID) or a username from the CLI.
# Returns how the message was handled.
#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
sub processPageEngine($$) {
    my ($sSender, $sOrigMessage) = @_;
    my $iSender;
    my $bRoomChanged = 0;
    my $bBypass      = ($sOrigMessage =~ /^\!/);

    # verify the sender;  note the below is assignment, not a test
    return 'Unknown paging user.' unless ($iSender = verifySendingUser($sSender));

    debugLog(D_pageEngine, "starting engine with iSender = $iSender, message = $sOrigMessage");
    my $iRoom = DSPS_Room::findUsersRoom($iSender);

    # substitute in user macros unless it's a paging command or a bypass message
    $sOrigMessage = replaceUserMacros($iSender, $sOrigMessage) unless ($sOrigMessage =~ /^\s*[?:!]/);
    my $sMessage = $sOrigMessage;

    # paging gateway companies insert random CRs that ruin our regexes
    $sMessage =~ s/\n//g;

    # check for escalation cancel possibilities
    # if the escalation was canceled by a RECOVERY then we prefix the message with '-'
    substr($sOrigMessage, 0, 0) = '-' if DSPS_Escalation::checkEscalationCancel($iSender, $sMessage);

    # determine if the sender's room (if they're in one) is in maintenance mode
    my $bMaintRoom = $iRoom ? $g_hRooms{$iRoom}->{maintenance} : 0;

    # see if there are paging commands to address
    unless (handlePagingCommands($iSender, $sMessage)) {

        # drop messages blocked by one of our system filters
        if (!DSPS_User::humanUsersPhone($iSender) && (my $sFiltered = DSPS_SystemFilter::blockedByFilter($sMessage, $iRoom))) {
            logPage($iSender, $sMessage, "FILTERED ($sFiltered)");
            return "Blocked by system filter ($sFiltered)";
        }

        # only pull other people in if its a human talking or a non-maintenance room
        if (DSPS_User::humanUsersPhone($iSender) || !$bMaintRoom) {

            # pull people, groups, etc into the room who are mentioned
            # also sets up escalation timers for oncall mentions
            unless ($bBypass) {
                if ($g_hUsers{$iSender}->{auto_include}) {
                    debugLog(D_pageEngine, "redirect is set for user " . $g_hUsers{$iSender}->{name} . "; only adding " . $g_hUsers{$iSender}->{auto_include});
                    $bRoomChanged = (processMentions($iSender, $g_hUsers{$iSender}->{auto_include}, $sOrigMessage) > 0) || $bRoomChanged;
                }
                else {
                    DSPS_Room::checkpointOccupants($iRoom) if $iRoom;
                    $bRoomChanged = (processMentions($iSender, $sMessage, $sOrigMessage) > 0) || $bRoomChanged;

                    # at this point $iRoom is the room the sender was in when this function started.  it may be 0 if the person wasn't in
                    # a room, even if the above processMention() has now put them in a room.  but if they weren't in a room at the start
                    # then there's no point in the below logic as there's no room history to search.  we also don't want to run this because
                    # it will instantiate a non-existent room (#0).  hence, "if ($iRoom)"
                    if ($iRoom && DSPS_User::humanUsersPhone($iSender) && $g_hRooms{$iRoom}->{last_nonhuman_message}) {

                        if (   $g_hRooms{$iRoom}->{escalation_orig_sender}
                            && !DSPS_User::humanUsersPhone($g_hRooms{$iRoom}->{escalation_orig_sender})
                            && ($g_hRooms{$iRoom}->{last_problem_time} >= time() - 120))
                        {

                            foreach my $iNewPhone (DSPS_Room::diffOccupants($iRoom)) {
                                sendSmsPage($iNewPhone, 'RESEND: ' . $g_hRooms{$iRoom}->{last_nonhuman_message});
                            }
                        }
                    }
                }
            }
        }

        # redetermine user's room after the procesMentions()
        $iRoom = DSPS_Room::findUsersRoom($iSender);

        # check for & potentially set broadcast mode
        if ($sOrigMessage =~ /^\^(.*)/) {
            $sOrigMessage = $1;    # drop carret

            if ($iRoom) {

                # is the room already in broadcast mode?
                if ($g_hRooms{$iRoom}->{broadcast_speaker} && (($iSender ne $g_hRooms{$iRoom}->{broadcast_speaker}) && !DSPS_CmdPermission::checkPermissions($iSender, '^'))) {
                    sendSmsPage($iSender, t(S_NoReBroadcast));
                }
                else {
                    $g_hRooms{$iRoom}->{broadcast_speaker} = $iSender;
                    debugLog(D_pageEngine, "Room $iRoom set to broadcast mode via message from " . $g_hUsers{$iSender}->{name} . " ($iSender)");
                    $bRoomChanged = "BROADCAST: replies only go to " . $g_hUsers{$iSender}->{name} . ';';
                }
            }
        }

        # remove any hidden aliases, remove redundant spaces
        $sOrigMessage = messagePostFixUp($sOrigMessage) unless $bBypass;

        sendUserMessageToRoom($iSender, $sOrigMessage, $bRoomChanged);
    }

    # if this is a human reply record the time in the room
    $g_hRooms{$iRoom}->{last_human_reply_time} = time() if ((defined $g_hRooms{$iRoom}) && DSPS_User::humanUsersPhone($iSender));

    # check for and potentially fire any valid triggers
    DSPS_Trigger::checkAllTriggers($iSender, $sOrigMessage);

    return 'Message submitted.';
}

#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
# Make sure the sender is a valid paging user
# and standardize the input (caller ID or user
# name) to caller ID.
#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
sub verifySendingUser($) {
    my $sSender = shift;

    # identify the message sender
    if ($sSender !~ /^\d+$/) {
        if (my $sMatchingUser = DSPS_User::matchUserByRegex($sSender)) {
            $sSender = $sMatchingUser;
        }
        else {
            infoLog("received message from unknown user ($sSender); ignoring");
            return 0;
        }
    }

    unless (defined $g_hUsers{$sSender}) {
        infoLog("received message from unknown user ($sSender); ignoring");
        return 0;
    }

    return $sSender;    # now normalized as the user's phone number
}

#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
# When the main daemon kicks off, immediately
# after backgrounding, this is it's main() start
# point.
# Handles:
#    - setting up the main listening socket
#    - looping through incoming socket connections,
#      sleeping at most 10 seconds between each
#    - socket timeouts / exception catching
#    - processing each of the 3 types of requests:
#          - regular message/command submission
#          - fire fast submission (gets immediate reply)
#          - print request for escalatino on call schedule
#    - room health checks - delete expired ones
#    - user health checks - delete expired vacations
#    - escalation check - fire off ones that are ready
# Never returns.
#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
sub daemonMain() {
    my ($sServerAddr, $iServerPort) = getServerAddress(1, '0.0.0.0', 2176);

    # open main server-side listening socket
    $g_tListenerSocket = HTTP::Daemon->new(
        Type      => SOCK_STREAM,
        Listen    => 50,
        Proto     => 'tcp',
        Reuse     => 1,
        LocalAddr => $sServerAddr,
        LocalPort => $iServerPort
    ) or die(infoLog("Can't create server listening socket: $!"));

    # setup our call to select() by adding our listener socket to a filehandle list
    my ($rtReadHandles) = new IO::Select();
    $rtReadHandles->add($g_tListenerSocket);

    restoreState();

    while (1) {

        # install signal handlers
        POSIX::sigaction(&POSIX::SIGTERM, $tSignalActionTerm);
        POSIX::sigaction(&POSIX::SIGHUP,  $tSignalActionHup);
        POSIX::sigaction(&POSIX::SIGINT,  $tSignalActionInt);

        eval {
            $0 = 'dsps: ' . ($g_bTEST_RUN ? 'test' : 'live') . " server process (perl) $g_sOriginalPath -d";
            infoLog('daemon starting in ' . ($g_bTEST_RUN ? 'TEST MODE' : 'live mode') . "; listening on $sServerAddr:$iServerPort");

            # daemon main loop
          DAEMON_MAIN: while (1) {

                # update daily stats for how many pages we've sent
                checkpointMetrics();

                # sleep at most 10 seconds waiting for a socket connection
                my ($rtReadSet) = IO::Select->select($rtReadHandles, undef, undef, 10);

                # loop through sockets that are ready to be read.  since we only keep our listening one open
                # that's the only socket we'll possibly get.  but this 'for' loop is actually a test for
                # whether we woke up for a socket connection versus just timing out because 30 seconds have
                # elapsed.  if we enter the 'for', we got a socket.
                foreach my $tReadSocketHandle (@$rtReadSet) {
                    my $oConnection;
                    my $oRequest;
                    my $rVars;

                    eval {
                        eval {
                            # set an alarm so we don't wait servicing this socket for too long
                            alarm(8);
                            local $SIG{ALRM} = sub {die "alarm\n";};

                            # accept the connection and parse the request
                            $oConnection = $g_tListenerSocket->accept();
                            $oRequest    = $oConnection->get_request();
                            $rVars       = CGI->new($oRequest->decoded_content())->Vars;
                        };
                        my $sException = $@;

                        # it's important to disable the existing alarm *outside* of the above [inner] eval().  otherwise
                        # if the HTTP::Daemon object throws an exception it would exit that eval with the alarm still set.
                        # hence we do it here.  and wrap it in an additional eval() in case the alarm goes off between the
                        # two code lines that bracket this comment (above & below).
                        alarm(0);

                        if ($sException eq "alarm\n") {
                            infoLog("ERROR:  timeout reading request" . ($oConnection ? " from " . $oConnection->peerhost() . ':' . $oConnection->peerport() : ''));
                            next;
                        }
                    };
                    my $sException = $@;

                    if ($sException) {
                        infoLog("EXCEPTION (inner): $sException");
                        sendEmail($g_hConfigOptions{admin_email}, '', "Subject: DSPS bug detected - exception in daemonMain (inner)\n\n$sException\n\ngrep dsps /var/log/syslog\n");
                        next DAEMON_MAIN;
                    }

                    next unless ((defined $oRequest) && $oRequest);

                    # verify http auth, if configured
                    my $bAuthOk = 1;
                    if (defined($g_hConfigOptions{http_auth})) {
                        $bAuthOk = 0;

                        if (defined($rVars->{auth})) {
                            while ($g_hConfigOptions{http_auth} =~ /([A-Z0-9-_+]+)/i) {
                                my $sKey = $1;

                                if ($sKey eq $rVars->{auth}) {
                                    $bAuthOk = $sKey;
                                    last;
                                }
                            }
                        }
                    }

                    eval {
                        my $sLiveStatus = $g_bTEST_RUN ? "   *** DAEMON IN TEST MODE - NOT LIVE ***\n" : '';
                        debugLog(D_pageEngine,
                                ($bAuthOk eq 1 ? "" : $bAuthOk ? "[Auth $bAuthOk] " : "[Auth FAILED] ")
                              . $oRequest->uri->path
                              . ' request from '
                              . $oConnection->peerhost() . ':'
                              . $oConnection->peerport()
                              . " specifying: "
                              . join(', ', sort keys %{$rVars}));

                        if ($bAuthOk) {

                            # look for submit requests - the majority of paging commands
                            if ($oRequest->uri->path eq '/submit') {
                                if (defined($rVars->{message}) && defined($rVars->{sender})) {

                                    if (defined($rVars->{fire_fast}) && ($rVars->{fire_fast} == 1)) {

                                        # in fire_fast mode we send the client the ack immediately and let them go on their way while we do the work
                                        # FWIW, most of what we do is prety fast anyway.  the real advantage is if we're creating an RT ticket on a
                                        # remote server that might make us slow to respond.
                                        $oConnection->send_response(HTTP::Response->new(200, 'OK', HTTP::Headers->new(), $sLiveStatus . "Message submitted\n"));
                                        processPageEngine($rVars->{sender}, dequote($rVars->{message}));
                                    }
                                    else {
                                        # main engine to process the incoming page and respond
                                        my $sStatus = processPageEngine($rVars->{sender}, dequote($rVars->{message}));

                                        # send a response back to the dsps client
                                        $oConnection->send_response(HTTP::Response->new(200, 'OK', HTTP::Headers->new(), $sLiveStatus . "$sStatus\n"));
                                    }
                                }
                                else {
                                    infoLog("ERROR:  socket connection that didn't specify message and sender; ignoring");
                                    $oConnection->send_response(HTTP::Response->new(400, 'FAIL', HTTP::Headers->new(), "Submission is invalid.\n"));
                                }
                            }

                            # print requests specifically from the client CLI
                            elsif ($oRequest->uri->path eq '/print') {
                                if (defined($rVars->{escalation})) {

                                    # has the client asked for the on call schedule of a valid escalation?
                                    if (my $sKey = caselessHashLookup($rVars->{escalation}, %g_hEscalations)) {
                                        $oConnection->send_response(HTTP::Response->new(201, 'OK', HTTP::Headers->new(), $sLiveStatus . DSPS_Escalation::getFullOncallSchedule($sKey)));
                                    }
                                    else {
                                        $oConnection->send_response(
                                            HTTP::Response->new(201, 'OK', HTTP::Headers->new(), $sLiveStatus . "There is no currently configured escalation with that name.\n"));
                                    }
                                }
                            }

                            # status request from the client CLI
                            elsif ($oRequest->uri->path eq '/status') {
                                my $sTriggers = DSPS_Trigger::triggerStatus();
                                my $sStatus = "ROOM OCCUPANTS\n" . DSPS_Room::roomStatus(0) . "\n\n" . filterStatus(0) . ($sTriggers ? "\n$sTriggers" : '');
                                $oConnection->send_response(HTTP::Response->new(201, 'OK', HTTP::Headers->new(), $sLiveStatus . $sStatus));
                            }
                        }
                        else {
                            $oConnection->send_response(HTTP::Response->new(403, 'FAIL', HTTP::Headers->new(), $sLiveStatus . "Invalid authentication.\n"));
                        }

                        $oConnection->close();
                    };
                    $sException = $@;

                    if ($sException) {
                        infoLog("EXCEPTION (middle): $sException [caught & continuing]");
                        $oConnection->close() if ($oConnection);
                        sendEmail($g_hConfigOptions{admin_email}, '', "Subject: DSPS bug detected - exception in daemonMain (middle)\n\n$sException\n\ngrep dsps /var/log/syslog\n");
                    }
                }

                # expire inactive rooms
                DSPS_Room::roomsHealthCheck();

                # delete expired vacation time
                DSPS_User::usersHealthCheck();

                # fire off escalations that are due
                DSPS_Escalation::checkEscalationTimes();
            }
        };

        if ($@) {
            my $sException = $@;
            infoLog("EXCEPTION (outer): $sException");
            infoLog("restarting daemonMain");
            sendEmail($g_hConfigOptions{admin_email}, '', "Subject: DSPS bug detected - exception in daemonMain (outer)\n\n$sException\n\nDaemon auto-restarting.");
        }
    }

    infoLog("exiting daemonMain");
}

#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
# Check to see if the daemon is already running
# Returns PID or 0.
#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
sub daemonAlreadyRunning() {
    my $iPID = shift || 0;
    my $bDaemonLives = 0;

    if (!$iPID && -f C_PIDPath) {
        if (open(PIDFile, C_PIDPath)) {
            $iPID = <PIDFile>;
            close(PIDFile);
        }
    }

    if ($iPID && kill(0, $iPID)) {
        return $iPID;
    }

    return 0;
}

#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
# Print CLI syntax help
#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
sub showUsage() {
    print
"dsps [-d | -s | -e | -i | -p escalation] [-c config_file] [-u user] [-x user] [message]\n   -d  (re)start the paging daemon in the background\n   -t  start the paging daemon in the foreground (for testing)\n   -s  submit a message (pipe to stdin or via CLI)\n";
    print "   -e  submit an email (pipe to stdin or via CLI), i.e. ignore headers\n   -u  specify the submitting paging user\n   -p  print current oncall schedule for a given escalation\n";
    print
"   -f  fast message submission to the daemon; don't wait for processing\n   -c  specify a config filename (default /etc/dsps.conf)\n   -x  exclusive page user (ignore rooms & daemon)\n   -i  show current status (info)\n   -v  show current version\n";
    print "\nRoom log attributes:\n";
    print "  [B] broadcast mode\n";
    print "  [M] maintenance mode\n";
    print "  [A] acknowledgement mode\n";
    print "  [T] ticket number associated\n";
    print "  [E] escalation armed\n";
}

#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
# DSPS is both a server daemon and client.  The
# CLI is the client and it can be used to submit
# messaegs/commands to the server.  This function
# is used by the client to make a request of the
# server via its HTTP API.
# Returns the text given back by the server or
# an error message if it can't connect.
#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
sub hitDspsApi($$) {
    my $sCommand = shift;
    my $rVars    = shift;

    my ($sServerAddr, $iServerPort) = getServerAddress(0, 'localhost', 2176);
    my $bSSL = ($iServerPort == 443) || ($sServerAddr =~ /^https:\/\//i);
    $sServerAddr = (($bSSL ? 'https' : 'http') . '://' . $sServerAddr) unless ($sServerAddr =~ /^http/i);

    my $tUserAgent = LWP::UserAgent->new(($bSSL ? (ssl_opts => { verify_hostname => 0 }) : ()));
    $tUserAgent->timeout(4);
    my $tRequest = $tUserAgent->post("$sServerAddr:$iServerPort/$sCommand", $rVars);

    if ($tRequest->is_success()) {
        return $tRequest->content();
    }
    else {
        if ($tRequest->code() == 500) {
            return "Unable to connect to paging daemon.  Is the daemon running?\n";
        }
        else {
            return "Error: " . $tRequest->content();
        }
    }
}

#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
# Read in the current config, validate the syntax
# and die if it's invalid.
#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
sub readValidConfigOrDie($) {
    my $sConfigFile = shift;

    unless (DSPS_Config::readConfig($sConfigFile) && DSPS_Config::configSyntaxValid()) {
        print infoLog("Aborting startup due to configuration errors.");
        exit(1);
    }
}



sub exclusivePage($$) {
    my $sPerson  = shift;
    my $sMessage = shift;

    if ($sPerson && (my $sMatchingUser = DSPS_User::matchUserByRegex($sPerson))) {
        infoLog("exclusively paging " . $g_hUsers{$sMatchingUser}->{name} . ": $sMessage");
        sendSmsPage($sMatchingUser, '!> ' . $sMessage);
    }
    else {
        print infoLog("no matching user found for '$sPerson'");
    }
}

#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
# This is the main logic for the client part of
# of DSPS (the companion to daemonMain()).
# Handles:
#   - processing CLI arguments
#   - submitting messages/commands to the server
#   - performing the startup config syntax check
#   - daemon startup if requested
#   - email header stripping for email submissions
#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
sub clientStartup() {
    my $bCmdDaemon       = 0;
    my $bCmdSubmit       = 0;
    my $bCmdSubmitEmail  = 0;
    my $bCmdStatus       = 0;
    my $bFireFast        = 0;
    my $bRunForeground   = 0;
    my $bVersion         = 0;
    my $sUser            = '';
    my $sEscalation      = '';
    my $sExclusivePerson = '';

    GetOptions(
        'd'        => \$bCmdDaemon,
        't'        => \$bRunForeground,
        's'        => \$bCmdSubmit,
        'e'        => \$bCmdSubmitEmail,
        'f'        => \$bFireFast,
        'x=s'      => \$sExclusivePerson,
        'i'        => \$bCmdStatus,
        'v'        => \$bVersion,
        'config=s' => \$g_sConfigFilename,
        'user=s'   => \$sUser,
        'print=s'  => \$sEscalation
    );

    my $sMessage = $ARGV[0] || '';
    my $sBogus   = $ARGV[1] || '';
    my $bValidStdIn = 0;

    if ($sBogus) {
        print infoLog("Too many parameters specified.  Did you forget quotes around your message text?");
        exit(1);
    }

    if ($bVersion) {
        print "dsps v$VERSION\n";
        exit(1);
    }

    # look for a message on STDIN
    if (!-t STDIN) {
        my @aStdin = <STDIN>;

        if ($#aStdin > -1) {
            print infoLog("Message specified on commandline AND piped in; concatting") if $sMessage;
            $sMessage = join('', @aStdin) . " $sMessage";
        }
    }

    if ($bCmdSubmit || $bCmdSubmitEmail || $sExclusivePerson) {
        readValidConfigOrDie($g_sConfigFilename);

        if (!$sMessage) {
            print infoLog("With " . ($sExclusivePerson ? 'Exclusive Person' : 'submit') . " you have to specify a message to send.");
            exit(1);
        }

        if ($sExclusivePerson) {
            if ($bCmdSubmit || $bCmdSubmitEmail) {
                print infoLog("Exclusive Person (-x) is mutually-exclusive with raw message submission (-s) and email submission (-e).");
                exit(1);
            }

            exclusivePage($sExclusivePerson, $sMessage);
            exit(1);
        }

        if ($bCmdSubmit && $bCmdSubmitEmail) {
            print infoLog("Raw message submission (-s) and email submission (-e) are mutually-exclusive.");
            exit(1);
        }

        unless ($sUser) {
            print infoLog("Messages have to be submitted from a specific paging user (-u).");
            exit(1);
        }

        # if the message contains an embedded sender that we're configured to recognize, switch to it
        if (my $sNewUser = checkUserOverride($sUser, $sMessage)) {
            $sUser = $sNewUser;
        }

        # if its an email, drop the headers
        if ($bCmdSubmitEmail) {
            my $bInBody          = 0;
            my $bQuotedPrintable = 0;
            my @aNewLines;
            my @aTempLines = split(/\n/, $sMessage);
            foreach (@aTempLines) {

                if (/^Content-Transfer-Encoding:\s+quoted-printable/i) {
                    $bQuotedPrintable = 1;
                }

                if ($bInBody) {
                    if ($bQuotedPrintable) {
                        s/=(\n*)$/$1/;
                        $_ = decode_qp($_);
                    }

                    s/\&apos;/\'/g;
                }

                $bInBody = 1 if (/^\s*$/);
                next if (!$bInBody || /^\s*$/);
                push(@aNewLines, $_);
            }

            $sMessage = join("\n", @aNewLines);
        }

        # submit the message to the daemon
        if (defined($g_hConfigOptions{http_auth}) && ($g_hConfigOptions{http_auth} =~ /([A-Z0-9-_+]+)/i)) {
            my $sKey = $1;
            print hitDspsApi('submit', [sender => $sUser, message => $sMessage, auth => $sKey, fire_fast => $bFireFast]);
        }
        else {
            print hitDspsApi('submit', [sender => $sUser, message => $sMessage, fire_fast => $bFireFast]);
        }
        exit(0);
    }

    # print oncall schedule for an escalation
    if ($sEscalation) {
        readValidConfigOrDie($g_sConfigFilename);

        if (defined($g_hConfigOptions{http_auth}) && ($g_hConfigOptions{http_auth} =~ /([A-Z0-9-_+]+)/i)) {
            my $sKey = $1;
            print hitDspsApi('print', [escalation => $sEscalation, auth => $sKey]);
        }
        else {
            print hitDspsApi('print', [escalation => $sEscalation]);
        }
        exit(0);
    }

    # print current status
    if ($bCmdStatus) {
        readValidConfigOrDie($g_sConfigFilename);

        if (defined($g_hConfigOptions{http_auth}) && ($g_hConfigOptions{http_auth} =~ /([A-Z0-9-_+]+)/i)) {
            my $sKey = $1;
            print hitDspsApi('status', [auth => $sKey]);
        }
        else {
            print hitDspsApi('status', []);
        }
        exit(0);
    }

    if ($bCmdDaemon && $bRunForeground) {
        print infoLog("ERROR: can't run in foreground and as daemon simultaneously");
        exit(0);
    }

    if ($bCmdDaemon || $bRunForeground) {
        if (my $iDaemonPID = daemonAlreadyRunning()) {

            # request to startup in the background when a daemon is already running in the background
            if ($bCmdDaemon) {
                print STDERR "restarting previously running background dsps daemon via SIGHUP...\n";
                kill('HUP', $iDaemonPID);
                exit(0);
            }

            # request to startup in foreground when a daemon is already running in the background
            kill('TERM', $iDaemonPID);
            sleep(1);

            if ($iDaemonPID = daemonAlreadyRunning()) {
                print STDERR "previously running daemon ignoring SIGTERM; trying SIGKILL...\n";
                kill('KILL', $iDaemonPID);
                sleep(1);

                if ($iDaemonPID = daemonAlreadyRunning()) {
                    print STDERR "ERROR: can't kill running (pid=$iDaemonPID) daemon; reboot?\n";
                    exit(1);
                }
            }
        }

        readValidConfigOrDie($g_sConfigFilename);

        if ($bCmdDaemon) {
            my $tDaemon = Proc::Daemon->new(work_dir => '/tmp', pid_file => C_PIDPath);
            my $iDaemonPid = $tDaemon->Init;
            daemonMain() unless $iDaemonPid;
        }
        else {
            $g_bTEST_RUN = 3 unless $g_bTEST_RUN;    # i.e. if already hardcoded to '1' then don't override that
            print "  *** RUNNING IN FOREGROUND ***\n";
            $g_iDebugTopics = $g_iTestingDebugTopics; 
            daemonMain();
        }
        exit(0);
    }

    showUsage();
}

#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
#-#  M A I N
#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#

clientStartup();

